###################
# Pentester Tasks #
###################
Reference:
http://blogs.technet.com/b/heyscriptingguy/archive/2012/07/02/use-powershell-for-network-host-and-port-discovery-sweeps.aspx


Listing IPs
One of the typical ways for working with IP addressed in most scripts is to work with an octet and then increase the last one

$octect = "192.168.6."
$lastoctect = (1..255)
$lastoctect | ForEach-Object {write-host "$($octect)$($_)"}

Ping Sweep
PowerShell provides several methods for doing Ping
Test-Connection cmdlet
Creation of a WMI Object
.Net System.Net.NetworkInformation.Ping Object

function New-IPRange ($start, $end) {
$ip1 = ([System.Net.IPAddress]$start).GetAddressBytes()
[Array]::Reverse($ip1)
$ip1 = ([System.Net.IPAddress]($ip1 -join '.')).Address

$ip2 = ([System.Net.IPAddress]$end).GetAddressBytes()
[Array]::Reverse($ip2)
$ip2 = ([System.Net.IPAddress]($ip2 -join '.')).Address

for ($x=$ip1; $x -le $ip2; $x++) {
$ip = ([System.Net.IPAddress]$x).GetAddressBytes()
[Array]::Reverse($ip)
$ip -join '.'
}
}
$ping = New-Object System.Net.NetworkInformation.Ping
New-IPRange 192.168.6.1 192.168.6.150 | ForEach-Object {$ping.Send($_, 100)} | where {$_.status -eq "Success"}

Reverse Lookups
For reverse lookups using .Net Class we use the [System.Net.Dns]::GetHostEntry(IP) method Returns System.Net.IPHostEntry

[System.Net.Dns]::GetHostByAddress("204.244.123.113")


Forward Lookups

[System.Net.Dns]::GetHostAddresses("www.google.com")

Port Scans
To test if a port is open on a remote host in PowerShell the best method is to use the .Net abstraction that it provides to Windows Socket library
For TCP the .Net System.Net.Sockets.TcpClient
For UDP the .Net System.Net.Sockets.UdpClient
TCP Scan

$ports=22,80
$target = "Strategic-Sec-Ubuntu-VM-IP"
foreach ($i in $ports) {
try {
$socket = new-object System.Net.Sockets.TCPClient($target, $i);
} catch {}
if ($socket -eq $NULL) {
echo "$target:$i - Closed";
} else {
echo "$target:$i - Open";
$socket = $NULL;
}}


PARSING NMAP RESULT
Run Powershell as administrator

cd C:\

Get-ExecutionPolicy
Set-ExecutionPolicy Unrestricted –Force



Parse nmap XML
.\parse-nmap.ps1 samplescan.xml

Process all XML files

.\parse-nmap.ps1 *.xml

Piping also works
dir *.xml | .\parse-nmap.ps1

Advanced parsing with filtering conditions
.\parse-nmap.ps1 samplescan.xml | where {$_.OS -like "*Windows XP*"} | format-table IPv4,HostName,OS

More parsing
.\parse-nmap.ps1 samplescan.xml | where {$_.Ports -like "*open:tcp:22*"}

Parsing with match and multiple conditions
.\parse-nmap.ps1 samplescan.xml |where {$_.Ports -match "open:tcp:80|open:tcp:443"}

CSV Export
.\parse-nmap.ps1 samplescan.xml -outputdelimiter " " | where {$_.Ports -match "open:tcp:80"} | export-csv weblisteners.csv

Import Data from CSV
$data = import-csv weblisteners.csv
$data | where {($_.IPv4 -like "10.57.*") -and ($_.Ports -match "open:tcp:22")}

Export to HTML
.\parse-nmap.ps1 samplescan.xml -outputdelimiter " " |select-object IPv4,HostName,OS | ConvertTo-Html | out-file report.html




Nessus with PowerShell

Let’s take a look at the Import-Csv cmdlet and what are the members of the object it returns:

Import-Csv C:\class_nessus.csv | Get-Member

filter the objects:

Import-Csv C:\class_nessus.csv | where {$_.risk -eq "high"}

use the Select-Object cmdlet and only get unique entries:

Import-Csv C:\class_nessus.csv | where {$_.risk -eq "high"} | select host -Unique

Import-Csv C:\class_nessus.csv | where {"high","medium","low" -contains $_.risk} | select "Plugin ID", CVE, CVSS, Risk, Host, Protocol, Port, Name | Out-GridView

 
ConvertTo-Html cmdlet and turn it in to an HTML report in list format:

Import-Csv C:\class_nessus.csv | where {"high","medium","low" -contains $_.risk} | select "Plugin ID", CVE, CVSS, Risk, Host, Protocol, Port, Name | ConvertTo-Html -As List > C:\report2.html



